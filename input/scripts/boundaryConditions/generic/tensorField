// get access to current boundary patch and field
const fvPatch& boundaryPatch = patch();
vectorField& field = *this;

// get access to computational mesh
const fvMesh& mesh = refCast<const fvMesh>(this->db());

// current (total) time
const scalar currentTime = this->db().time().value();

// loop over all boundary faces if requires
forAll(field, faceI)
{
    // example usage shown below
    // access to boundary face coordinates
    const auto x = boundaryPatch.Cf()[faceI].x();
    const auto y = boundaryPatch.Cf()[faceI].y();
    const auto z = boundaryPatch.Cf()[faceI].z();

    // set field based on location in space and time as required
    if (y > 0.5)
    {
        field[faceI].xx() = 1;
        field[faceI].xy() = 0;
        field[faceI].xz() = 0;
        field[faceI].yx() = 0;
        field[faceI].yy() = 1;
        field[faceI].yz() = 0;
        field[faceI].zx() = 0;
        field[faceI].zy() = 0;
        field[faceI].zz() = 1;
    }
    else
    {
        field[faceI].xx() = 0;
        field[faceI].xy() = 0;
        field[faceI].xz() = 0;
        field[faceI].yx() = 0;
        field[faceI].yy() = 0;
        field[faceI].yz() = 0;
        field[faceI].zx() = 0;
        field[faceI].zy() = 0;
        field[faceI].zz() = 0;
    }
}