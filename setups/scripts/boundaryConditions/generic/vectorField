// get access to current boundary patch and field
const fvPatch& boundaryPatch = patch();
vectorField& field = *this;

// get access to computational mesh
const fvMesh& mesh = refCast<const fvMesh>(this->db());

// current (total) time
const scalar currentTime = this->db().time().value();

// loop over all boundary faces if requires
forAll(field, faceI)
{
    // example usage shown below
    // access to boundary face coordinates
    const auto x = boundaryPatch.Cf()[faceI].x();
    const auto y = boundaryPatch.Cf()[faceI].y();
    const auto z = boundaryPatch.Cf()[faceI].z();

    // set field based on location in space and time as required
    if (y > 0.5)
    {
        field[faceI].x() = 0.02 * currentTime;
        field[faceI].y() = 0.01 * currentTime;;
        field[faceI].z() = 0.0;
    }
    else
    {
        field[faceI].x() = 0;
        field[faceI].y() = 0;
        field[faceI].z() = 0;
    }
}